function p = randomPointAtDistance(L, input )
%
%     p = randomPointAtDistance( L, p0 )
%     p = randomPointAtDistance( L, D )
%
% This function returns a point in multivariate normal space, as a struct 
% with 'mu' and 'SIGMA' fields, that lies a manifold distance L from the
% point p0 (specified using a struct in the same way).
% If instead the dimension D is provided, the starting point is taken as 
% the origin in D-variate MVN space.
%
% Points are randomly generated by treating each element of the mean vector
% and covariance matrix's lower triangle as independent. A random point on
% this D+D(D+1)/2-sphere is selected, and a geodesic with that velocity is
% traced out the requested distance

% If a point was input, transform that point to the origin
if isstruct(input)
    
    % Validate the provided point and read out its dimension
    [p0, D] = validatePoints( input );
    
    % Transform this point to the origin
    [~, P, r] = affineToOrigin(p0);
    
% If a dimension was input, just store that dimension and use a null
% transform (starting point is origin)
else
    
    % Create the origin in the requested dimension
    D = input;
    
    % Transform to be applied is a null transform
    P = eye(D);
    r = zeros(D,1);
    
end

% Calculate number of parameters from dimension of the MVNs
Np = D + D*(D+1)/2;

% Find a random point on the Np-sphere
z = randn(Np,1);
z = z / norm(z);

% Grab out the first portion of the random vector - mean vector
v.mu = z(1:D);
% Grab out the remainder as the vectorisation of the covariance matrix
vSIGMA = z(D+1:end);
% Create a mask to easily access only the lower triangle
trilMask = tril( true(D) );
% Fill in the mask with its vector list of values
v.SIGMA = zeros(D);
v.SIGMA( trilMask ) = vSIGMA;
% Fill in the matrix's upper triangle with the same values
v.SIGMA = v.SIGMA + v.SIGMA' - diag( diag( v.SIGMA ) );

% Create a geodesic with this velocity beginning at the origin
G = struct('v',v,'P',P,'r',r);
% Fire this geodesic the requested distance to get the point
p = fireGeodesic(G,L);

end